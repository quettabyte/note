---
title: Redux的原理与写法
date: 2022-11-04 20:22:10
author: cokeice
tags: [JavaScript, React, redux]
categories: 
    - 笔记
    - React框架
index_img: /img/react/react.webp
---

<p align='center'>
<a href="https://www.github.com/Cokeic" target="_blank"><img src="https://img.shields.io/badge/Github-@可乐冰-f3e1e1.svg?style=flat-square&logo=Github&logoColor=181717"></a><a href="https://www.gitee.com/Cokeice" target="_blank"><img src="https://img.shields.io/badge/Gitee-@可乐冰-f3e1e1.svg?style=flat-square&logo=Gitee&logoColor=C71D23"></a><a href="https://cokeice.gitee.io/img/wechat/wx.png" target="_blank"><img src="https://img.shields.io/badge/微信-@LNFeng-f3e1e1.svg?style=flat-square&logo=WeChat"></a>

## Redux工作流程📚

<img src="https://cokeiceimg-1313926630.cos.ap-beijing.myqcloud.com/img/redux-yuanli.jpg" style="zoom:50%;" />

客户-服务员-老板-厨师🤣

## redux精简版

1. 去除Count组件自身的状态

2. 📂`src`下建立:

   * -redux

   * -store.js
   * -count_reducer.js

3. 📄`store.js`：

   * 引入redux中的createStore函数，创建一个store
   * createStore调用时要传入一个为其服务的reducer
   * 记得暴露store对象

   ```js
   /* 该文件专门用于暴露一个store对象，整个应用只有一个store对象*/
   //引入createStore，专门用于创建redux中最为核心的store对象
   import {createStore} from 'redux'
   //引入为Count组件服务的reducer
   import countReducer from './count_reducer'
   //暴露store
   export default createStore(countReducer)
   ```

4. 📄`count_reducer.js`：

   * reducer的本质是一个函数，接收：preState,action，返回加工后的状态
   * reducer有两个作用：初始化状态，加工状态
   * reducer被第一次调用时，是store自动触发的，
     * 传递的preState是undefined,
     * 传递的action是:{type:'@@REDUX/INIT_a.2.b.4}

   ```js
   /* 
   	1.该文件是用于创建一个为Count组件服务的reducer，reducer的本质就是一个函数
   	2.reducer函数会接到两个参数，分别为：之前的状态(preState)，动作对象(action)
   */
   const initState = 0 //初始化状态
   export default function countReducer(preState=initState,action){
   	// console.log(preState);
   	//从action对象中获取：type、data
   	const {type,data} = action
   	//根据type决定如何加工数据
   	switch (type) {
   		case 'increment': //如果是加
   			return preState + data
   		case 'decrement': //若果是减
   			return preState - data
   		default:
   			return preState
   	}
   }
   ```

5. 在📄`index.js`中监测store中状态的改变，一旦发生改变重新渲染`<App/>`

   * 📜备注：redux只负责管理状态，至于状态的改变驱动着页面的展示，要靠我们自己写。
   * 💢注意：react-redux中不需要监听，因为创建容器组件会自动监测store中的状态，从而调render

   ```js
   const myroot = document.getElementById('root')
   const root = ReactDOM.createRoot(myroot)
   root.render(<App />)
   store.subscribe(()=>{
   	root.render(<App />)
   })
   ```

## redux 完整版

与精简版的主要区别🧩：（新增文件）

* 📄`count_action.js` 专门用于创建action对象
* 📄`constant.js` 放置容易写错的type值

```js
// 该文件专门为Count组件生成action对象
import {INCREMENT,DECREMENT} from './constant'
export const increment = data => ({type:INCREMENT,data})
export const decrement = data => ({type:DECREMENT,data})
//-----------------分隔线-----------------
// 该模块是用于定义action对象中type类型的常量值，
// 目的只有一个：便于管理的同时防止程序员单词写错
export const INCREMENT = 'increment'
export const DECREMENT = 'decrement'
```

## redux——异步action

1. ✔明确：延迟的动作不想交给组件自身，想交给action

2. 何时需要异步action：想要对状态进行操作，但是具体的数据靠异步任务返回。

3. ✒具体编码：
   1. yarn add redux-thunk，并配置在store中

      ```shell
      npm install redux-thunk
      ```

   2. 创建action的函数不再返回一般对象，而是一个函数，该函数中写异步任务。

      ```js
      //异步action，就是指action的值为函数,
      //异步action中一般都会调用同步action，异步action不是必须要用的。
      export const createIncrementAsyncAction = (data,time) => {
      	return (dispatch)=>{
      		setTimeout(()=>{
      			dispatch(createIncrementAction(data))
      		},time)
      	}
      }
      //-----------------分隔线-----------------
      import {createStore,applyMiddleware} from 'redux'
      import thunk from 'redux-thunk' //引入redux-thunk，用于支持异步action
      export default createStore(reducer,applyMiddleware(thunk))
      ```

   3. 异步任务有结果后，分发一个同步的action去真正操作数据。

4. 🎯备注：异步action不是必须要写的，完全可以自己等待异步任务的结果了再去分发同步action。

## React-Redux基本概念

<img src="https://cokeiceimg-1313926630.cos.ap-beijing.myqcloud.com/img/react-redux-yuanli.jpg" style="zoom:50%;" />

1. ✔明确两个概念：
   * UI组件:不能使用任何redux的api，只负责页面的呈现、交互等。
   * 容器组件：负责和redux通信，将结果交给UI组件。

2. 🎨如何创建一个容器组件————靠react-redux 的 connect函数
   * connect(mapStateToProps,mapDispatchToProps)(UI组件)
     * -mapStateToProps:映射状态，返回值是一个对象
     * -mapDispatchToProps:映射操作状态的方法，返回值是一个对象

3. 🎯备注：
   * 容器组件中的store是靠props传进去的，而不是在容器组件中直接引入
   * mapDispatchToProps，也可以是一个对象（简写）
   * 使用了react-redux后也不用再自己检测redux中状态的改变了，容器组件可以自动完成这个工作。

## react-redux基础写法

> 做项目的时候不这么写，会使用简写，但是这个基础写法更容易看懂其中的逻辑与各个文件间的关系

```shell
npm install react-redux
```

1. UI组件

   📂`components`

   ```jsx
   import React, { Component } from 'react'
   export default class Count extends Component {
   	increment = ()=>{ //加法
   		const {value} = this.selectNumber
   		this.props.jia(value*1)
   	}
   	decrement = ()=>{ //减法
   		const {value} = this.selectNumber
   		this.props.jian(value*1)
   	}
   	incrementIfOdd = ()=>{ //奇数再加
   		const {value} = this.selectNumber
   		if(this.props.count % 2 !== 0){
   			this.props.jia(value*1)
   		}
   	}
   	incrementAsync = ()=>{ //异步加
   		const {value} = this.selectNumber
   		this.props.jiaAsync(value*1,500)
   	}
   	render() {
   		return (
   			<div>
   				<h1>当前求和为：{this.props.count}</h1>
   				<select ref={c => this.selectNumber = c}>
   					<option value="1">1</option>
   					<option value="2">2</option>
   					<option value="3">3</option>
   				</select>&nbsp;
   				<button onClick={this.increment}>+</button>&nbsp;
   				<button onClick={this.decrement}>-</button>&nbsp;
   				<button onClick={this.incrementIfOdd}>当前求和为奇数再加</button>&nbsp;
   				<button onClick={this.incrementAsync}>异步加</button>&nbsp;
   			</div>
   		)
   	}
   }
   ```

2. 容器组件

   📂`container`

   ```js
   //引入Count的UI组件
   import CountUI from '../../components/Count'
   //引入action
   import {
   	createIncrementAction,
   	createDecrementAction,
   	createIncrementAsyncAction
   } from '../../redux/count_action'
   
   //引入connect用于连接UI组件与redux
   import {connect} from 'react-redux'
   
   /* 
   	1.mapStateToProps函数返回的是一个对象；
   	2.返回的对象中的key就作为传递给UI组件props的key,value就作为传递给UI组件props的value
   	3.mapStateToProps用于传递状态
   */
   function mapStateToProps(state){
   	return {count:state}
   }
   
   /* 
   	1.mapDispatchToProps函数返回的是一个对象；
   	2.返回的对象中的key就作为传递给UI组件props的key,value就作为传递给UI组件props的value
   	3.mapDispatchToProps用于传递操作状态的方法
   */
   function mapDispatchToProps(dispatch){
   	return {
   		jia:number => dispatch(createIncrementAction(number)),
   		jian:number => dispatch(createDecrementAction(number)),
   		jiaAsync:(number,time) => dispatch(createIncrementAsyncAction(number,time)),
   	}
   }
   
   //使用connect()()创建并暴露一个Count的容器组件
   export default connect(mapStateToProps,mapDispatchToProps)(CountUI)
   ```

3. 📄`store.js`

   ```js
   /* 
   	该文件专门用于暴露一个store对象，整个应用只有一个store对象
   */
   
   //引入createStore，专门用于创建redux中最为核心的store对象
   import {createStore,applyMiddleware} from 'redux'
   //引入为Count组件服务的reducer
   import countReducer from './count_reducer'
   //引入redux-thunk，用于支持异步action
   import thunk from 'redux-thunk'
   //暴露store
   export default createStore(countReducer,applyMiddleware(thunk))
   ```

4. 📄`countant.js`定义action对象中type类型的常量值

   ```js
   /* 
   	该模块是用于定义action对象中type类型的常量值，目的只有一个：便于管理的同时防止程序员单词写错
   */
   export const INCREMENT = 'increment'
   export const DECREMENT = 'decrement'
   ```

5. 📄`count_action.js` 创建action对象用的

   ```js
   /* 
   	该文件专门为Count组件生成action对象
   */
   import {INCREMENT,DECREMENT} from './constant'
   
   //同步action，就是指action的值为Object类型的一般对象
   export const createIncrementAction = data => ({type:INCREMENT,data})
   export const createDecrementAction = data => ({type:DECREMENT,data})
   
   //异步action，就是指action的值为函数,异步action中一般都会调用同步action，异步action不是必须要用的。
   export const createIncrementAsyncAction = (data,time) => {
   	return (dispatch)=>{
   		setTimeout(()=>{
   			dispatch(createIncrementAction(data))
   		},time)
   	}
   }
   ```

6. 📄`count_reducer.js` 创建一个为Count组件服务的reducer

   ```js
   /* 
   	1.该文件是用于创建一个为Count组件服务的reducer，reducer的本质就是一个函数
   	2.reducer函数会接到两个参数，分别为：之前的状态(preState)，动作对象(action)
   */
   import {INCREMENT,DECREMENT} from './constant'
   
   const initState = 0 //初始化状态
   export default function countReducer(preState=initState,action){
   	// console.log(preState);
   	//从action对象中获取：type、data
   	const {type,data} = action
   	//根据type决定如何加工数据
   	switch (type) {
   		case INCREMENT: //如果是加
   			return preState + data
   		case DECREMENT: //若果是减
   			return preState - data
   		default:
   			return preState
   	}
   }
   ```

7. 📄`App.jsx` 渲染这个组件到页面

   ```jsx
   import React, { Component } from 'react'
   import Count from './containers/Count'
   import store from './redux/store'
   
   export default class App extends Component {
   	render() {
   		return (
   			<div>
   				{/* 给容器组件传递store */}
   				<Count store={store} />
   			</div>
   		)
   	}
   }
   ```

## react-redux简写

> 需要配合上面的基础写法来看

1. 将UI组件与容器组件整合成一个文件

   📂`container`

   ```jsx
   //导入所需的模块
   import ....
   
   //UI组件放在这里，不需要默认导出，因为只有容器组件需要调用
   class Count extends Component {
       ...;
   }
   
   //容器组件放在这
   ```

2. 容器组件中connect中给UI组件传递的props简写

   ```jsx
   //引入action
   
   //基础版看上面的基础写法
   export default connect(
       state => ({key:value}), //映射状态
       {key:xxxxxAction} //映射操作状态的方法
       // 尽量触发对象的简写形式
   )(UI组件)
   ```

3. 把所有组件的reducer文件放在📂`src/redux/reducers`下

4. 把所有组件的action文件放在📂`src/redux/actions`下

5. 在📂`reducers`下新建📄`index.js`文件专门用于汇总并暴露所有的reducer

   ```js
   //引入combineReducers，用于汇总多个reducer
   import {combineReducers} from 'redux'
   //引入为各个组件服务的reducer
   
   //汇总所有的reducer变为一个总的reducer
   //key1和key2就是以后从redux中获取各个组件共享状态的key值
   export default  combineReducers({
   	key1:reducer1,
   	key2:reducer2
   })
   ```

6. 无需自己给容器组件传递store，给`<App/>`包裹一个`<Provider store={store}>`即可

   ```jsx
   import store from './redux/store'
   import {Provider} from 'react-redux'
   root.render(
   	/* 此处需要用Provider包裹App，目的是让App所有的后代容器组件都能接收到store */
   	<Provider store={store}>
   		<App/>
   	</Provider>
   )
   ```

7. **一个组件要和redux“打交道”要经过哪几步？**

   * 定义好UI组件---不暴露

   * 引入connect生成一个容器组件，并暴露，写法如下：

     ```js
     connect(
         state => ({key:value}), //映射状态
         {key:xxxxxAction} //映射操作状态的方法
     )(UI组件)
     ```

   * 在UI组件中通过this.props.xxxxxxx读取和操作状态

## redux数据共享

需要共享的容器组件的reducer要使用combineReducers进行合并，合并后的总状态是一个对象！！！

具体写法看上面`<react-redux简写>`中的`5.`

## react-redux开发者工具的使用

```shell
npm install redux-devtools-extension
```

⚙store中进行配置 

​	📄`store.js`

```js
import {composeWithDevTools} from 'redux-devtools-extension'
const store = createStore(allReducer,composeWithDevTools(applyMiddleware(thunk)))
```

💦浏览器中安装Redux DevTools













