## docker-compose工具

### 一、介绍

```
docker-compose是一个单机容器编排工具，基于python开发
```

#### 1、安装docker-compose

```
# curl -L "https://github.com/docker/compose/releases/download/1.29.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose

# chmod a+x /usr/local/bin/docker-compose

[root@test ~]# docker-compose version
docker-compose version 1.29.0, build 07737305
docker-py version: 5.0.0
CPython version: 3.7.10
OpenSSL version: OpenSSL 1.1.0l  10 Sep 2019

```

#### 2、使用流程

```
1、按照需求规划目录
2、在该目录创建名称为docker-compose.yml文件, 该文件中主要描述容器的部署信息
3、运行docker-compose up -d拉取容器
```

##### 示例1: 

```
[root@test ~]# tree test1
test1
└── docker-compose.yml

0 directories, 1 file

```

```
[root@test test1]# cat docker-compose.yml 
version: '3'
services:
    web:
      image: nginx
    redis:
      image: redis
      
```

```
[root@test test1]# docker-compose up -d 
```



##### 示例2: 

```
[root@test test2]# tree
.
├── docker-compose.yml
├── Dockerfile
└── index.html

0 directories, 3 files

```

```
[root@test test2]# cat Dockerfile 
FROM nginx:latest

ADD ./index.html /usr/share/nginx/html

```

```
[root@test test2]# cat docker-compose.yml 
version: '3'
services:
    redis:
       image: redis
    web:
       build: ./
       
[root@test test1]# docker-compose up -d 
```

```
默认情况下，使用docker-compose工具创建的容器、镜像的命名方式: 

	容器命名方式:
		当前目录_服务名称_数字
		
	镜像命名方式:
		当前目录_服务名称
```



### 二、docker compose常用命令

#### 1、常用命令

```
1、 docker-compose up -d

参数:
	1) --scale	web=2
		横向扩展，将名称为web的容器启动两个
	
	2）-f选项
		默认名称为docker-compose.yml文件，-f可指定其他文件名，不建议使用
	
3、docker-compose ps

4、docker-compose {start|stop|restart}

5、docker-compose down
	停止删除容器、默认网络
	
6、docker-compose top
```

```
7、docker-compose build
	当目录下的dockerfile发生变动时，默认情况下，docker-compose并不会重构镜像，需要执行该命令手动重新构建，再执行docker-compose up -d重建容器
```



### 三、docker compose文件语法 

#### 1、整体结构 

```
1、version
2、services
3、networks
4、volumes
```

#### 1、version

```
指定docker-compose语法版本 

https://docs.docker.com/compose/compose-file/
```

#### 2、services

```
定义运行的容器信息 
```

```
version: "3"
services:
	容器名称:
		.....
		.....
	容器名称:
		.....
		.....
networks:
volumes:
```

##### 容器名称下的指令：

```
image: 镜像名称
```

```
volumes:
- 物理机目录:容器目录
```

```
command: "/run.sh"

command:
- "/run.sh"
```

```
建立容器网络链接

links:
- 容器名称:别名
```

```
映射端口

ports:
- "5000:5000"
```

```
声明要暴露的端口

expose: 6379
```

```
定义环境变量

environment:
	- KEY: VALUE
	- KEY: VALUE
```

```
定义服务依赖关系

depends_on:
- redis
- xxxx
```

```
deploy:		#定义容器的部署方式 
	replicas: 3
	restart_policy:
		condition: on-failure
	update_config:
		parallelism: 2
		delay: 10s
		
replicas: 指定容器的副本数

update_config: 定义容器更新时的操作

    parallelism: 2，滚动更新，一次更新两个
    delay: 一次更新两个等待10s后再继续更新
    failure_action: pause， 如果更新失败，执行的动作：continue, rollback, pause(默认)
    max_failure_ratio: 在更新过程中容忍的失败率
    order: stop-first	更新时的操作顺序, stop-first, start-first
```



```
resources:		容器的资源限制
	limits:
		cpus: "0.50"
		memory: 50M
	reservations:
		cpus: "0.25"
		memory: 20M
```

​		

```
healthcheck:		# 健康状态检测
	test: ["CMD", "curl", "-f", "http://localhost"]
	interval: 10s
	timeout: 10s
	retries: 3
	start_period: 40s
```

```
network_mode: "bridge"
network_mode: "host"
network_mode: "none"
```

```
dns: 8.8.8.8

dns:
- 8.8.8.8
- 4.4.4.4
```



#### 示例: 部署web集群 

```
[root@test haproxy-web]# tree 
.
├── docker-compose.yml
├── Dockerfile
├── haproxy.cfg
├── webA
│   └── index.html
└── webB
    └── index.html

2 directories, 5 files

```

```
[root@test haproxy-web]# cat Dockerfile 
FROM haproxy:latest
COPY haproxy.cfg /usr/local/etc/haproxy/haproxy.cfg
```

```
[root@test haproxy-web]# cat docker-compose.yml 
version: "3"
services:
    webA:
       image: httpd
       volumes:
         - ./webA:/usr/local/apache2/htdocs/
       expose: ["80"]

    webB:
       image: httpd
       volumes:
         - ./webB:/usr/local/apache2/htdocs
       expose: ["80"]

    haproxy-director:
       build: ./
       depends_on:
          - webA
          - webB
       links:
          - webA:webA
          - webB:webB
       ports:
          - "8888:80"
          - "9188:9188"

```

```
[root@node01 docker]# cat haproxy.cfg 
global
       maxconn 2000
       nbproc 1
       log 127.0.0.1 local0 info
       daemon
       pidfile /var/run/haproxy.pid

defaults
       retries 3
       timeout connect 5s
       timeout client 10s
       timeout server 30s
       timeout check 2s
       stats uri /haproxy-status
frontend web_service
       bind 0.0.0.0:80
       mode http
       log global
       option forwardfor
       default_backend server_web

backend server_web
       mode http
       option redispatch
       cookie SERVERID
       option abortonclose
       balance roundrobin
       server v01 webA:80 check	
       server v02 webB:80 check
listen admin_status                                     
        bind 0.0.0.0:9188 
        mode http
        stats refresh 30s                               
        stats uri /haproxy-status               
        stats realm Welcome login               
        stats auth admin:redhat
        stats hide-version                              
        stats admin if TRUE  
```





















