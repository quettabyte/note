## 进程调度 

### 一、通过信号影响进程的运行方式 

```
查看Linux系统支持信号  

[root@localhost ~]# kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR

向进程发送信号 
# kill 信号 PID
```

```
杀死进程

15：正常结束进程,  默认
9:  强制杀死

[root@localhost ~]# kill 1485

[root@localhost ~]# kill -9 1516
```



```
挂起进程
19: 暂停运行一个进程
18：继续运行一个进程
```



```
信号 1
	使进程重新加载配置文件

编辑nginx配置文件

# vim nginx安装目录/conf/nginx.conf 

	listen 9999

[root@localhost ~]# ps -elf | grep nginx 
1 S root       1872      1  0  80   0 -  5125 sigsus 09:40 ?        00:00:00 nginx: master process /usr/local/nginx/sbin/nginx
5 S nobody     1873   1872  0  80   0 -  5757 ep_pol 09:40 ?        00:00:00 nginx: worker process
0 S root       1929   1327  0  80   0 - 28165 pipe_w 09:41 pts/0    00:00:00 grep --color=auto nginx

[root@localhost ~]# kill -1 1872
```



```
killall  结束多个同名的进程

[root@localhost ~]# killall vim
```





### 二、控制进程在前后台运行 

```
1、将正在运行的任务放入后台暂停运行

	ctrl + z 
	
2、查看后台任务

[root@localhost ~]# jobs -l
[1]+  2086 Stopped                 vim /etc/fstab


3、将后台任务调回前台运行 

# fg 任务编号 
```



```
1、将任务放入后台运行 

# command & 

[root@localhost ~]# dd if=/dev/zero of=/file01 bs=1M count=5000 & 

2、将任务放入后台运行 【推荐使用】

# nohup command & 

[root@localhost ~]# nohup dd if=/dev/zero of=/file01 bs=1M count=50000 & 
```





### 三、计划任务

```
计划任务类型：
	1、一次性任务 
	2、周期性任务 
```



#### 1、一次性任务

```
前提: 
	依赖于atd服务正常运行状态  
	
[root@localhost ~]# systemctl status atd
● atd.service - Job spooling tools
   Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled; vendor preset: enabled)
   Active: active (running) since Thu 2020-12-31 17:18:07 CST; 6h left
   
设置一次性任务 

[root@localhost ~]# at 10:48
at> mkdir /tmp/testdir
at> 按ctrl + d提交任务 
job 1 at Thu Dec 31 10:48:00 2020
```



#### 2、周期性任务

```
前提:
	依赖于crond服务正常运行 
	
[root@localhost ~]# systemctl status crond
● crond.service - Command Scheduler
   Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor preset: enabled)
   Active: active (running) since Thu 2020-12-31 17:18:07 CST; 6h left
 Main PID: 1104 (crond)
   CGroup: /system.slice/crond.service
           └─1104 /usr/sbin/crond -n
```



```
创建计划任务 
[root@localhost ~]# crontab -e			//为当前用户设置计划任务 

        时间            操作

时间:

    分  时  日   月   周 

    30  20  * * *   每天晚上八点半 
    0   10  * *  5  每周五上午十点
    0  8-10 * * 3   每周三上午八点到十点
    30 10,13,17 * * * 
    */30 * * * *    每半小时
    0  10-22/2 * * * 

操作:
	1) 建议所有命令以绝对路径方式写   /usr/bin/ls 
	2) 一个时间点只能对应一条命令,  shell脚本
```



##### 案例: 每隔2分钟同步时间 

```
创建计划任务
[root@localhost ~]# crontab -e
*/2 * * * *  /usr/sbin/ntpdate 120.25.115.20

查看计划任务
[root@localhost ~]# crontab -l
*/2 * * * *  /usr/sbin/ntpdate 120.25.115.20

注意: 
	计划任务执行操作时，如果该操作会产生信息，默认计划任务会将信息作为邮件发送给当前用户 

[root@localhost ~]# crontab -l
*/2 * * * *  /usr/sbin/ntpdate 120.25.115.20 &> /dev/null
```



##### 案例: 每隔一分钟创建目录 

```
注意: 
	计划任务默认认为%为命令的结束符，如果命令中存在%，需要进行转义 

[root@localhost ~]# crontab -l
*/1 * * * *  /usr/bin/mkdir /tmp/$(date +\%F_\%T)
```



##### 案例: 每隔2分钟，搜集系统的运行状态(cpu负载、磁盘使用情况，内存使用情况)

```
[root@localhost ~]# cat /root/test.sh 
#!/bin/bash

uptime
df -hT
free -m



[root@localhost ~]# crontab -l

*/1 * * * *  /usr/bin/bash /root/test.sh
```













