### 一、rabbitmq安装部署 

#### 1、下载epel源

```
[root@bogon ~]# wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
```

#### 2、安装启动rabbitmq

```
[root@bogon ~]# yum install rabbitmq-server
[root@bogon ~]# systemctl start rabbitmq-server
[root@bogon ~]# systemctl enable rabbitmq-server
[root@bogon ~]# netstat -tunlp
[root@bogon ~]# systemctl status rabbitmq-server.service 
```

#### 3、启用rabbitmq web管理界面 

```
[root@bogon ~]# rabbitmq-plugins enable rabbitmq_management
[root@bogon ~]# chown -R rabbitmq.rabbitmq /var/lib/rabbitmq/
[root@bogon ~]# rabbitmqctl add_user admin WWW.1.com
[root@bogon ~]# rabbitmqctl set_user_tags admin administrator
[root@bogon ~]# rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"
[root@bogon ~]# systemctl restart rabbitmq-server.service 
```

#### 4、访问web界面 

```
http://192.168.183.10:15672
```



### 二、通过python连接rabbitmq

#### 安装pika模块

```
C:\Users\admin>pip install pika -i https://repo.huaweicloud.com/repository/pypi/simple

C:\Users\admin>python
Python 3.6.5 (v3.6.5:f59c0932b4, Mar 28 2018, 17:00:18) [MSC v.1900 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>>
>>> import pika
>>> exit()
```



#### 1、发布消息

```
import pika

token = pika.PlainCredentials(username="admin", password="WWW.1.com")
conn = pika.BlockingConnection(pika.ConnectionParameters(host="192.168.183.10", port=5672, credentials=token))
channel = conn.channel()
channel.queue_declare(queue="test")
channel.basic_publish(exchange='', routing_key='test', body="Hello rabbit!!!")
print("send success msg to rabbitmq")
conn.close()
```

#### 2、订阅消息

```
import pika
token = pika.PlainCredentials(username="admin", password="WWW.1.com")
conn = pika.BlockingConnection(pika.ConnectionParameters(host="192.168.183.10", port=5672, credentials=token))

channel = conn.channel()
channel.queue_declare(queue="test")

//定义用于处理接收到的消息的函数
def callback(ch, method, properities, body):
    print(" [x] Received %s" % body)

channel.basic_consume('test', callback, False)
print("waiting.........")
channel.start_consuming()
```



### 三、rabbitmq用户管理

#### 1、角色

```
即权限

RabbitMQ用户角色分为5类，超级管理员（administrator）、监控者（monitoring）、策略制定者（policymaker）、普通管理者（management）、其他（none）。

1、超级管理员（administrator）

   可登录图形界面控制台，可查看所有信息，可以对用户、策略、虚拟机进行操作。

2、监控者（monitoring）

   可登录图形界面控制台，可查看RabbitMQ的内存、进程、磁盘等使用情况。

3、策略制定者（policymaker）

   可登录图形界面控制台，可以对策略进行管理，但是不能查看节点相关信息。

4、普通管理者（management）

   仅可登录图形界面控制台。

5、其他（none）

        无法登录控制台。
```

#### 2、用户管理操作

```
[root@bogon ~]# rabbitmqctl --help | grep -i user
    add_user <username> <password>
    delete_user <username>
    change_password <username> <newpassword>
    clear_password <username>
    set_user_tags <username> <tag> ...
    list_users
    set_permissions [-p <vhostpath>] <user> <conf> <write> <read>
    clear_permissions [-p <vhostpath>] <username>
    list_user_permissions <username>
```





### 四、rabbitmq集群

#### 1、集群模式

```
1、普通模式
	默认模式，以两个节点（rabbit01、rabbit02）为例来进行说明。对于Queue来说，消息实体只存在于其中一个节点rabbit01（或者rabbit02），rabbit01和rabbit02两个节点仅有相同的元数据，即队列的结构。当消息进入rabbit01节点的Queue后，consumer从rabbit02节点消费时，RabbitMQ会临时在rabbit01、rabbit02间进行消息传输，把A中的消息实体取出并经过B发送给consumer。所以consumer应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理Queue。否则无论consumer连rabbit01或rabbit02，出口总在rabbit01，会产生瓶颈。当rabbit01节点故障后，rabbit02节点无法取到rabbit01节点中还未消费的消息实体。如果做了消息持久化，那么得等rabbit01节点恢复，然后才可被消费；如果没有持久化的话，就会产生消息丢失的现象。

2、镜像模式
	把需要的队列做成镜像队列，存在与多个节点属于RabbitMQ的HA方案。该模式解决了普通模式中的问题，其实质和普通模式不同之处在于，消息实体会主动在镜像节点间同步，而不是在客户端取数据时临时拉取。该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。所以在对可靠性要求较高的场合中适用。
```



#### 2、部署普通模式集群

```
环境描述:

192.168.183.10	rabbit01
192.168.183.11	rabbit02
```

##### 1)、添加主机名解析 

```
[root@rabbit01 ~]# vim /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6

192.168.183.10 rabbit01
192.168.183.11 rabbit02

[root@rabbit01 ~]# rsync -av /etc/hosts root@192.168.183.11:/etc/hosts
```

##### 2)、在两台服务器分别安装启动rabbitmq

```
[root@rabbit01 ~]# wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
[root@rabbit01 ~]# yum install -y rabbitmq-server 
[root@rabbit01 ~]# systemctl start rabbitmq-server
[root@rabbit01 ~]# systemctl enable rabbitmq-server

[root@rabbit01 ~]# rabbitmq-plugins enable rabbitmq_management

[root@rabbit01 ~]# rabbitmqctl add_user martin redhat
[root@rabbit01 ~]# rabbitmqctl set_user_tags martin administrator
[root@rabbit01 ~]# systemctl restart rabbitmq-server
```

##### 3)、设置集群节点通信认证的cookie

```
rabbitmq集群依赖于erlang集群， erlang集群认证时需要用于.erlang.cookie文件，该文件存在于$HOME或/var/lib/rabbitmq目录
确认两台服务器该文件内容一致

[root@rabbit01 ~]# rsync -av .erlang.cookie root@192.168.183.11:/root/
[root@rabbit01 ~]# chmod 600 .erlang.cookie 

[root@rabbit01 ~]# cat .erlang.cookie 
LAVRCRYPRVKBPAHJMVNN[root@rabbit01 ~]# 

[root@rabbit02 ~]# cat .erlang.cookie
LAVRCRYPRVKBPAHJMVNN[root@rabbit02 ~]# 
```

##### 4)、查看集群状态

```
[root@rabbit01 ~]# rabbitmqctl cluster_status
Cluster status of node rabbit@rabbit01 ...
[{nodes,[{disc,[rabbit@rabbit01]}]},
 {running_nodes,[rabbit@rabbit01]},
 {cluster_name,<<"rabbit@rabbit01">>},
 {partitions,[]}]
...done.
```

##### 5)、将另外一个节点加入集群

```
[root@rabbit01 ~]# rabbitmqctl stop_app
Stopping node rabbit@rabbit01 ...
...done.
[root@rabbit01 ~]# 
[root@rabbit01 ~]# 
[root@rabbit01 ~]# rabbitmqctl join_cluster --ram rabbit@rabbit02
Clustering node rabbit@rabbit01 with rabbit@rabbit02 ...
...done.
[root@rabbit01 ~]# 
[root@rabbit01 ~]# rabbitmqctl start_app
Starting node rabbit@rabbit01 ...
...done.

[root@rabbit01 ~]# rabbitmqctl cluster_status
Cluster status of node rabbit@rabbit01 ...
[{nodes,[{disc,[rabbit@rabbit02]},{ram,[rabbit@rabbit01]}]},
 {running_nodes,[rabbit@rabbit02,rabbit@rabbit01]},
 {cluster_name,<<"rabbit@rabbit02">>},
 {partitions,[]}]
...done.
```

##### 6)、在web界面查看节点运行状态 

![image-20210326144311272](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210326144311272.png)



#### 3、设置镜像高可用集群模式

```
[root@rabbit01 ~]# rabbitmqctl set_policy ha-all "^" '{"ha-mode":"all"}'
Setting policy "ha-all" for pattern "^" to "{\"ha-mode\":\"all\"}" with priority "0" ...
...done.
```

```
参数说明:

1、ha-all：策略名称 

2、^：匹配符
	一个^表示匹配所有
	^test: 表示匹配名称为test的exchange或queue

3、ha-mode：表示匹配模式，共有3种 

	1) all	    队列会被镜像到集群所有节点
	2) exactly	明确指定队列会被镜像的份数; 例如 2
	3) nodes		队列会被镜像到指定的集群节点；例如["rabbit@rabbit03", "rabbit@rabbit04"]

```

![image-20210326144900576](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210326144900576.png)









