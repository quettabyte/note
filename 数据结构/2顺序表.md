# 第二章 线性表

## 2.1 线性表及其基本操作 

2022年3月14日 16:22

### 2.1.1 线性表的定义

​	**线性表**是由$n(n>=0)$个类型相同的数据元素$a_1,a_2,\ldots ,a_n $组成的有限序列。

​	数据元素之间是一对一的关系，即每个数据元素最多有一个直接前驱和一个直接后继。

​	线性表的逻辑结构图为：⚪—⚪—⚪—⚪—⚪



### 2.1.2 线性表的特点

* 同一性：线性表由同类数据元素组成，每一个$a_i$必须属于同一数据对象。

* 有穷性：线性表由有限个数据元素组成，表长度就是表中数据元素的个数。

* 有序性：线性表中相邻数据元素之间存在着序偶关系$<a_i,a_{i+1}>$ 。

  

### 2.1.3 抽象数据类型定义

​	ADT LinearList{

​		数据元素：D={，，为某一数据对象 }

​		关系：S={}

​		基本操作：

​		（1）InitList（L）		操作前提：L为未初始化线性表

​								操作结果：将L初始化为空表

​		（2）DestroyList（L）	操作前提：线性表L已存在

​								操作结果：将L销毁

​		（3）ClearList（L）		操作前提：线性表L已存在

​								操作结果：将表L置为空表

​	}ADT LinearList



## 2.2 线性表的顺序存储结构(数组)

2022年3月14日 16:30

> 线性表的顺序存储是指用一组地址连续的存储单元依次存储线性表中的各个元素，使得线性表中在逻辑结构上相邻的数据元素存储再相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。采用顺序存储结构的线性表通常称为**顺序表**。



### 2.2.1 顺序存储结构的C语言定义（学籍表）

| num   | name    | sex  | age  | score | addr    |
| ----- | ------- | ---- | ---- | ----- | ------- |
| 10010 | Li Fang | M    | 18   | 87.5  | Beijing |

```c
#define maxsize 100 //线性表可能达到的最大长度
typedef struct
{
  int num;//学号
  char name[20];//姓名
  char sex;//性别
  int age;//年龄
  double score;//出生年月日
  char addr[30];//家庭住址
}ElemType;
typedef struct
{
  ElemType elem[maxsize];/*线性表占用的数组空间*/
  int last;/*记录线性表中的最后一个元素在数组elem[]中的位置(下标值)，空表置为-1*/
}SeqList;
```

```c
//1.定义结构体变量
ElemType s1;	//定义一个存放学籍表的变量，用来存放一名学生的学籍表
Seqlist  L1;	//定义一个顺序表变量，用来存放多名学生的学籍表
//2.将学籍表的一行记录写入s1
//结构体变量的成员引用运算符：
s1.num = 10010;
strcpy(s1.name,"LiFang");
s1.sex = 'M';
s1.age = 18;
s1.score = 87.5;
strcpy(s1.addr,"Beijing")
```



### 2.2.2 查找操作

在线性表中查找某一个元素，按序号或者按内容查找

* 按序号查找

  ```c
  //要求查找线性表L中第i个数据
  //其结果是：L.elem[i-1]，由参数e带回主调函数
  //函数返回值是函数执行的状态，如果i在1至n=L.last+1之间，函数返回1，否则返回0
  int GetData(SeqList L,int i,ElemType *e)//变量参数，单向值传递方式，由实参单方向传递（复制）给形参
  {
    if(i >= 1 && i <= L.last+1){
      *e = L.elem[i-1];
      return 1;
    }
    return 0;
  }
  ```

  

* 按内容查找

  ```c
  //要求查找线性表L中与给定内容e相等的数据元素
  //其结果是：若在表L中找到与e相等的元素，则利用指针i返回给用户该元素在表中的序号，并return 1
  //若找不到，则返回一个“空序号”，return 0
  int Locate(SeqList *L,ElemType e,int *i)//指针参数，传递是地址，对形参的改变就是对实参的改变
  {
    int k;
    *i = -1;
    for(k = 0;k <= L->last;k++)
    {
      if(L->elem[k] == e){
        *i = k+1;
        return 1;
      }
    }
    return 0;
  }
  ```



### 2.2.3 插入操作

在线性表中的某一位置插入一个数据元素

```c
#define ERROR 	0
#define OK		1

int InsList(SeqList *L,int i,ElemType e)
{
  int k;
  
  /*首先判断插入位置是否合法*/
  if((i < 1) || (i > L-last+2)){
    printf("插入位置i值不合法");
    return (ERROR);
  }
  if(L-last >= maxsize-1){
    printf("表以满无法插入");
    return (ERROR);
  }
  
  /*为插入元素而移动位置*/
  for(k = L->last;k >= i-1;k--)
  	L->elem[k+1] = L->elem[k];
  
  /*在C语言中数组第i个元素的下标为i-1*/
  L->elem[i-1] = e;
  L->last++;
  return OK;
}
```



### 2.2.4 删除操作

删除线性表中的某一个元素

```c
#define ERROR 	0
#define OK		1

//在顺序表L中删除第i个数据元素，并用指针参数e返回其值
int DelList(SeqList *L,int i,ElemType *e)
{
  int k;
  if((i < 1) || (i > L->last+1)){
    printf("删除位置不合法");
    return(ERROR);
  }
  
  /*将删除的元素存放到e所指向的变量中*/
  *e = L->elem[i-1];
  
  /*将后面的元素依次前移*/
  for(k = i;i <= L->last;k++)
    L->elem[k-1] = L->elem[k];
  L->last--;
  return(OK);
}
```



### 2.2.5 合并操作

有两个顺序表LA和LB，其元素均为非递减有序排列，编写一个算法，将他们合并成一个顺序表LC，要求LC也是非递减有序排列。

```c
//二路归并算法
void merge(SeqList *LA, SeqList *LB, SeqList *LC)
{
  int i = 0,j = 0,k = 0;
  while(i <= LA->last && j <= LB->last)
  {
    if(LA->elem[i] <= LB->elem[j]){
      LC->elem[k] = LA->elem[i];
      k++;i++;
    }else{
      LC->elem[k] = LB->elem[j];
      k++;j++;
    }
  }
  
  /*当表LA长则将表LA余下的元素赋给表LC*/
  while(i <= LB->last)
  {
    LC->elem[k] = LA->elem[i];
    i++;k++;
  }
  
  /*当表LB长则将表LB余下的元素赋给表LC*/
  while(j <= LB->last)
  {
    LC->elem[k] = LB->elem[j];
  	j++;k++;
  }
  LC->last = LA->last + LB->last;
}
```



### 2.2.6 顺序存储结构的优点和缺点

* 优点：
  1. 无需为表示节点间的逻辑关系而增加额外的存储空间；
  2. 可方便地随机存储表中的任一元素。
* 缺点
  1. 插入或删除运算不方便，除表尾位置外，在表的其它位置上进行插入或删除操作都必须移动大量的结点，其效率较低；
  2. 由于顺序表要求要占用连续的存储空间，存储分配只能预先进行静态分配。因此当表长变化较大时，难以确定合适的存储规模。




## 2.3 单链表

2022年3月21日 17:45

### 2.3.1 单链表基本定义

> 单链表：链表中每个结点只有一个指针域，我们将这种链表称为单链表

结点（Node）：为了正确地表示结点间的逻辑关系，必须在存储线性表的每个数据元素值的同时，存储只是其后继节点的地址（或位置）信息，这两部分信息组成的存储映像叫做结点。

头指针：指向链表头节点的指针。

* 带头节点的单链表示意图

  ![01.png](https://cokeice-pic.oss-cn-wulanchabu.aliyuncs.com/2.png)

* 单链表的存储结构描述

  ```c
  typedef struct Node{//结点类型定义
    ElemType data;
    struct Node *next;
  }Node,*LinkList;	//LinkList为结构指针类型
  ```


> **扩展**
>
> 全局区：全局变量	、静态变量(static)
>
> 代码区：程序代码
>
> 栈区 ：函数调用状态值(主调函数的运行位置)、局部变量、形参
>
> 堆区：动态存储区，使用malloc()申请存储空间，free()释放存储空间
>
> ```c
> void *malloc(size_t size);
> /*标准库 <stdlib.h>
>   参数：size -- 内存块的大小，以字节为单位。
>   返回值：该函数返回一个指针 ，指向已分配大小的内存。如果请求失败，则返回 NULL。*/
>
> void free(void *ptr);
> /*标准库 <stdlib.h>
>   参数：ptr -- 指针指向一个要释放内存的内存块，该内存块之前是通过调用 malloc、calloc 或 realloc 进行分配内存的。如果传递的参数是一个空指针，则不会执行任何动作。
>   返回值：无*/
> ```
>
> 



### 2.3.2 建立单链表

* 头插法建表算法

  描述：从一个空表开始，重复读入数据，生成新结点，将读入数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头结点之后，直至读入结束标志为止。

  ![9Ktt8.png](https://cokeice-pic.oss-cn-wulanchabu.aliyuncs.com/3.png)

  ![9Ktsd.png](https://cokeice-pic.oss-cn-wulanchabu.aliyuncs.com/4.png)

  ```c
  LinkList CreateFromHead()//每次将新增字符放到头结点指向的位置
  {
    LinkList L;
    Node *s;
    int flag = 1;
    L = (Linklist)malloc(sizeof(Node));
    L->next = NULL;
    while(flag)
    {
      c = getchar();
      if(c != '$'){
        s = (Node *)malloc(sizeof(Node));
        s->data  = c;
        s->next = L->next;
        L->next = s;
      }else{
        flag = 0;
      }
    }
    return L;
  }
  ```

* 尾插法建表

  ![9K7H2.png](https://cokeice-pic.oss-cn-wulanchabu.aliyuncs.com/5.png)

  ```c
  LinkList CreateFromTail()//将新增的字符追加到链表的末尾
  {
    LinkList L;
    Node *r,*s;
    int flag = 1;
    L = (Node *)malloc(sizeof(Node));
    L->next = NULL;
    r = L;
    while(flag)
    {
      c = getchar();
      if(c != '$'){
        s = (Node *)malloc(sizeof(Node));
        s->data = c;
        r->next = s;
        r = s;
      }else{
        flag = 0;
        r->next = NULL;
      }
    }
    return L;
  }
  ```

  ```c
  //遍历链表，输出链表的各个结点数据
  void PrintList(LinkList L)
  {
    Node *p;
    p = L->next;
    while(p)
    {
      printf("%c",p->data);
      p = p->next;
    }
    printf("\n");
  }
  ```

* 测试

  ```c
  void main()
  {
    Node L1,L2;
    L1 = CreateFromHead();
    PrintList(L1);
    printf("\n");
    L2 = CreateFromTail();
    PrintList(L2);
    printf("\n");
    system("pause");
  }
  ```

* 运行结果

  ```c
  Input:	Hello World!$
  Output:	!dlroW olleH
  Input:	Hello World!$
  Output:	Hello World!
  ```

  

### 2.3.3 查找操作

查找操作分为按**序号**查找和按**值**查找

* 按序号查找算法

  ```c
  Node *Get(LinkList L,int i)
  {
    Node *p;
    p = L; j = 0;
    while((p->next != NULL) && (j < i))
    {
      p = p->next;
      j++;
    }
    if(i == j)
      return p;
    else
      return NULL;
  }
  ```

* 按值查找算法

  ```c
  Node *Locate(LinkList L,ElemType key)
  {
    Node *p;
    p = L->next;
    while(p != NULL)
      if(p->data != key)
        p = p->next;
    	else
        break;
    return p;
  }
  ```



### 2.3.4 插入操作

描述：在带头结点的单链表中第i个元素之前插入一个数据元素e，需要首先在单链表中找到第i-1个结点并由指针pre指示，然后申请一个新的结点并由指针s指示，其数据域的值为e，并修改第i-1个结点的指针使其指向s，然后使s结点的指针域指向第i个结点。

![9K69R.png](https://cokeice-pic.oss-cn-wulanchabu.aliyuncs.com/6.png)

* 单链表插入操作算法实现

  ```c
  void InsList(LinkList L,int i,ElemType e)
  {
    Node *pre, *s;
    pre = L;
    int k = 0;
    while(pre != NULL && k < i-1)
    {
      pre = pre->next;
      k = k + 1;
    }
    if(k != i-1){
      printf("插入位置不合理！\n");
      return;
    }
    s = (Node *)malloc(sizeof(Node));
    s->data = e;
    s->next = pre->next;
    pre->next = s;
  }
  ```

  

### 2.3.5 删除操作

描述：在带头结点的单链表L中删除第i个结点，则首先要通过计数方式找到第i-1个结点，并使p指向第i-1个结点，而后删除第i个结点并释放结点空间。

![JbhKg.png](https://cokeice-pic.oss-cn-wulanchabu.aliyuncs.com/7.png)

```c
//在带头结点的单链表L中删除第i个元素，并保存其值到变量*e中
int DelList(LinkList L,int i,ElemType *e)
{
  Node *p,*r;
  p = L;
  int k = 0;
  
  //寻找被删除结点i的前驱结点
  while(p->next != NULL && k < i-1)
    p = p->next; k = k+1;
  
  if(k != i-1){//即while循环是因为p->next = NULL而跳出的
    printf("删除结点的位置i不合理！\n");
    return ERROR;
  }
  
  //删除结点r
  r = p->next;
  p->next = p->next->next;
  *e = r->data;
  
  //释放被删除结点所占的内存空间
  free(r);
  return OK;
}
```



### 2.3.6 求单链表长度

描述：可以采用“数”结点的方法来求出单链表的长度，用指针p依次指向各个结点，从第一个元素开始“数”，一直“数”到最后一个结点（p->next=NULL）

```c
//L为带头结点的单链表
int ListLength(LinkList L)
{
  Node *p;
  int j;
  p = L;
  j = 0;//用来存放单链表的长度
  while(p->next != NULL)
  {
    p = p->next;
    j++;
  }
  return j;
}
```



### 2.3.7 合并操作

描述：要求利用现有的表LA和LB中的结点空间来建立新表LC，可通过更改结点的next域来重建新的元素之间的线性关系，为保证新表仍然递增有序，可以利用尾插法建立单链表的方法，只是新建表中的结点不用malloc，而只需要从表LA和LB中选择合适的点插入到新表LC中即可。、

```c
//将递增有序的点链表LA和LB合并成一个递增有序的单链表LC
LinkList MergeLinkList(LinkList LA,LinkList LB)
{
  Node *pa,*pb;
  LinkList LC,r;
  pa = LA->next;
  pb = LB->next;
  LC = LA;
  LC->next = NULL;
  r = LC;
  //当两个表中均为处理完时，比较选择较小值结点插入到新表LC中
  while(pa != NULL && pb != NULL)
  {
    if(pa->data <= pb->data){
      r->next = pa;
      r = pa;
      pa = pa->next;
    }else{
      r->next = pb;
      r = pb;
      pb = pb->next;
    }
  }
  if(pa)	//若表LA未完，将表LA中后续元素链到新表LC表尾
    r->next = pa;
  else		//否则将表LB中后续元素链到新表LC表尾
    r->next = pb;
  free(LB);
  return LC;
}
```



## 2.4 循环链表

2022年3月28日 16:38

**循环链表(Circular Linked List)**是一个首尾相接的链表

**特点**：将单链表最后一个结点的指针域由NULL改为指向头结点或线性表中的第一个结点，就得到了单链形式的循环链表，并称为循环单链表。在循环单链表中，表中所有结点被链在一个环上。

**示意图**：带头结点的循环单链

![JbvF7.png](https://cokeice-pic.oss-cn-wulanchabu.aliyuncs.com/8.png)

### 2.4.1 查找、插入、删除

和单链表的算法是一样的

[查找](#2.3.3 查找操作)

[插入](#2.3.4 插入操作)

[删除](#2.3.5 删除操作)

### 2.4.2 合并

描述：有两个带头结点的循环单链表LA、LB，将它们合并为一个循环单链表，其头指针为LA

算法思想：先找到两个链表的尾，并分别由指针p、q指向它们，然后将第一个链表的尾与第二个表的第一个结点链接起来，并修改第二个表的尾Q，使它的链域指向第一个表的头结点。

```c
//此算法将两个链表的首尾连接起来
LinkList merge_1(LinkList LA,LinkList LB)
{
  Node *p,*q;
  p = LA;
  q = LB;
  while(p->next != LA)
    p = p->next;		//找到表LA的表尾
  while(q->next != LB)
    q = q->next;		//找到表LB的表尾
  q->next = LA;			//修改表LB的尾指针，使之指向表LA中的头结点
  p->next = LB->next;	//修改表LA的尾指针，使之指向表LB中的第一个结点
  free(LB);
  return LA;
}
```



## 2.5 双向链表

2022年3月28日 16:48

> **双向链表(Double Linked List)**：在单链表的每个结点里再增加一个指向其前驱的指针域prior。这样形成的链表中就有两条方向不同的链，我们称为双向链表。

### 2.5.1 双向链表的结构定义

```c
typedef struct Dnode
{
  ElemType data;
  struct Dnode *prior,*next;
}DNode, *DoubleList;
```

* 双链表的结点结构

  ![JVrqC.png](https://cokeice-pic.oss-cn-wulanchabu.aliyuncs.com/9.png)



### 2.5.2 双向循环链表

* 示意图

  ![JVh2t.png](https://cokeice-pic.oss-cn-wulanchabu.aliyuncs.com/10.png)



### 2.5.3 双向链表的前插操作

描述：在双向链表第i个结点之前插入一个新的结点。

![JV4Ie.png](https://cokeice-pic.oss-cn-wulanchabu.aliyuncs.com/11.png)

```c
int DlinkIns(DoubleList L,int i,ElemType e)
{
  DNode *s,*p;
  if(i <= 0)
    return ERROR;
  p = L;
  int j = 0;
  while(p->next != L && j < i)
  {
    p = p->next;
    j++;
  }
  if(j < i)
    return ERROR;
  s = (DNode *)malloc(sizeof(DNode));
  if(s){
    s->data = e;
    s->prior = p->prior;
    p->prior->next = s;
    s->next = p;
    p->prior = s;
    return TRUE;
  }else
    return FALSE;
}
```



### 2.5.4 双向链表的删除操作

描述：删除双向链表中的第i个结点，则指针的变化情况如图所示。

![JZIhg.png](https://cokeice-pic.oss-cn-wulanchabu.aliyuncs.com/12.png)

```c
int DlinkDel(DoubleList L,int i,ElemType *e)
{
  DNode *p; 
  //if ERROR 判断插入位置i是否合法
  *e = p->data;
  p->prior->next = p->next;
  p->next->prior = p->prior;
  free(p);
  return TRUE;
}
```



## 2.6 静态链表

2022年3月28日 17:08

### 2.6.1 基本概念

之后讲







## 2.7 线性表的应用

2022年3月28日 17:09 

### 2.7.1 一元多项式的表示及相加

一元多项式可按升幂的形式写成：

$Pn(x)=p_0+p_1X^1+p_2X^2+\cdots+p_nX^n$



* 一元多项式的顺序存储表示

  ​	方法一：只存储该一元多项式的各项的系数，每个系数所对应的指数项则隐含在存储系			数的顺序表的下标中。适合存储非零系数多的多项式。 [具体算法](#2.7.2 顺序存储方法一) 

  ​	方法二：采用只存储非零项的方法，此时每个非零项需要存储：非零项系数和非零项指数。适合存储表示非零项少的多项式。 [具体算法](#2.7.3 顺序存储方法二) 

* 一元多项式的链式存储表示

  ​	在链式存储中，对一元多项式只存非零项，则该多项式中每一非零项由两部分构成（指数项和系数项），用单链表存储表示的结点结构为 [具体算法](#2.7.5 链式存储) 

  ![JVMEg.png](https://cokeice-pic.oss-cn-wulanchabu.aliyuncs.com/13.png)

  

### 2.7.2 顺序存储方法一

 ```c
#define MAXSIZE 100
typedef int ElemType;

typedef struct
{
  ElemType cof[MAXSIZE];
  int last;
}SeqList;

void input(SeqList *p,int n)
{
  int i;
  for(i = 0;i <= n-1;i++)
    scanf("%d",&p->cof[i]);
  p->last = n-1
}

void output(SeqList *p)
{
  int i;
  for(i = 0;i <= last;i++)
    printf("%3d",p->cof[i]);
  printf("\n");
}
//多项式合并算法
void Polyadd(SeqList *px, SeqList *qx, SeqList *rx)
{
  int i = 0,k = 0;
  if(px->last <= qx->last)
    k = px->last;
  else
    k = qx->last;
  for(i = 0;i <= k;i++)
    rx->cof[i] = px->cof[i] + qx->cof[i];
  
  if(px->last < qx->last){
    for(i = px->last+1;i <= qx->last;i++)
      rx->cof[i] = qx->cof[i]; 
    rx->last = qx->last;
  }else{
    for(i = qx->last+1;i <= px->last;i++)
    	rx->cof[i] = px->cof[i];
    rx->last = px->last;
  }
}

void main()
{
  //输入px
  //输入qx
  //Polyadd(),合并px和qx为rx
  //输出rx
}
 ```



### 2.7.3 顺序存储方法二

```c
typedef struct polynode
{
  int cof;
  int exp;
}PolyItem;

typedef struct
{
  PolyItem data[100];
  int last;
}SeqPoly;

//多项式合并算法
void merge_poly(SeqPoly *px,SeqPoly *qx,SeqPoly *rx)
{
  int i,j,k,sum;
  i = j = k = 0;
  while(i <= px->last && j <= last)
  {
    if(px->data[i],exp == qx->data[j].exp){
      sum = px->data[i].cof + qx->data[j].cof;
      if(sum != 0){
        rx->data[k].cof = sum;
        rx->data[k].exp = px->data[i].exp;
        k++; i++; j++;
      }else{
        i++; j++;
      }
    }else if(px->data[i]){
      rx->data[k].cof = px->data[i].cof;
      rx->data[k].exp = px->data[i].exp;
      k++; i++;
    }else{
      rx->data[k].cof = qx->data[j].cof;
      rx->data[k].exp = qx->data[j].exp;
      k++; j++;
    }
  }
  while(i <= px->last)
  {
    rx->data[k].cof = px->data[i].cof;
    rx->data[k].exp = px->data[i].exp;
    k++; i++;
  }
  while(j <= qx->last)
  {
    rx->data[k].cof = qx->data[j].cof;
    rx->data[k].exp = qx->data[j].exp;
    k++; j++;
  }
}

void input(SeqPoly *px)
{
  int c,e;
  int i = 0;
  printf("输入多项式的各项系数和指数，输入0，0结束\n");
  scanf("%d,%d",&c,&e);
  while(c != 0)
  {
    px->data[i].cof = c;
    px->data[i].exp = e;
    i++;
    scanf("%d,%d",&c,&e);
  }
}

void output(SeqPoly *px)
{
  for(int i = 0;i <= px->last;i++)
  	printf("%d %d\n",px->data[i].cof,px->data[i].exp);
  printf("\n")
}

void mian()
{
  //输入px
  //输入qx
  //merge_poly(),合并px和qx为rx
  //输出rx
}
```



### 2.7.4 链式存储

* 示意图

  $$A(x)=7+3x+9x^8+5x^{17}$$

  $$B(x)=8x+22x^7+9x^8$$

  ![JVV17.png](https://cokeice-pic.oss-cn-wulanchabu.aliyuncs.com/14.png)

```c
//用单链表存储多项式的结点结构
typedef struct Polynode
{
  int coef;
  int exp;
  struct Polynode *next;
}Polynode, *Polylist;

//创建表
Polylist PolyCreate()
{
  Polynode *head,*rear,*s;
  int c,e;
  head(Polynode *)malloc(sizeof(Polynode));//建立多项式的头结点
  rear = head;	//rear始终指向表尾 尾插法
  printf("请按照递增的顺序输入多项式的每一项元素的系数和指数 \
  			(用空格隔开，输入0 0结束)：\n");
  
  sacnf("%d %d",&c,&e);	//输入系数和指数
  while(c != 0)
  {
    s = (Polynode *)malloc(sizeof(Polynode));//申请新结点
    s->coef = c;
    s->exp = e;
    rear->next = s;
    rear = s;
    sacnf("%d %d",&c,&e);
  }
  rear->next = NULL;
  return head;
}

//多项式合并算法
Polylist PolyAdd(Polylist a,Polylist b)
{//就地算法
  Polynode *p,*q,*temp,*tail;
  int sum;
  p = a->next;
  q = b->next;
  tail = a;
  while(p != NULL && q != NULL)
  {
    if(p->exp < q->exp){			//a表的当前元素指数小
      tail->next = p;				//把这个元素直接给a
      tail = p;						//再把tail指向p
      p = p->next;					//p向后移一个
    }else if(p->exp > q->exp){		//b表当前元素指数小
      tail->next = q;
      tail = q;
      q = q->next;
    }else{							//相等的时候
      sum = p->coef + q->coef;		
      if(sum != 0){
        p->coef = sum;				//把这个和直接赋给p的系数
        tail->next = p;				//把p给a
        tail = p;					//tail = tail->next
        p = p->next;
        temp = q;					//释放
        q = q->next;
        free(temp);
      }else{						//同类项系数的和为0
        temp = p;
        p = p->next;
        free(temp);
        temp = q;
        q = q->next;
        free(temp);
      }
    }
  }
  if(p != NULL)
    tail->next = p;
  else
    tail->next = q;
  free(b);
  return a;
}

//遍历多项式链表，输出多项式的各项
void printpoly(Polylist PA)
{
  Polynode *p;
  p = PA->next;
  while(p)
  {
    printf("%d  %d\n",p->coef,p->exp);
    p = p->next;
  }
}

void main()
{
  //输入a
  //输入b
  //PolyAdd(),合并a和b为c
  //printpoly()输出c
}
```



## 2.8 顺序表和链式表的比较

2022年3月30日 15:15

### 2.8.1 基于空间

* 在链表中的每个结点，除了数据域外，还要额外设置指针域，从存储密度来讲，这是不经济的。所谓存储密度(Storage Density)，是指结点数据本身所占的存储量和整个结点结构所占的存储量之比，即存储密度=结点数据本身所占的存储量/整个结点所占的存储量
* 存储密度越大，存储空间利用率就越高。
* 顺序表的存储密度为1，而链表的存储密度小于1。
* 由此可知，当线性表的长度变化不大，易于事先确定其大小时，为了节约存储空间，宜采用顺序表作为存储结构。



### 2.8.2 基于时间

* 顺序表是由向量实现的，它是一种随机存储结构，对表中任一结点都可以在O(1)时间内直接地存取，而链表中的结点，需从头指针起顺着链找才能取得。
* 若线性表的操作主要是进行查找，很少做插入和删除时，宜采用顺序表做存储结构。
* 在链表中的任何位置上进行插入和删除，都只需要修改指针。而在顺序表中进行插入和删除，平均要移动表中近一半的结点，尤其是当每个结点的信息量较大时，移动结点的时间开销就相当可观。
* 对于频繁进行插入和删除的线性表，宜采用链表做存储结构。若表的插入和删除主要发生在表的首尾两端，则宜采用尾指针表示的单循环链表。



### 2.8.3 基于语言

* 对于没有提供指针类型的高级语言，若要采用链表结构，则可以使用光标实现的静态链表。
* 虽然静态链表在存储分配上由不足之处，但它和动态链表一样，具有插入和删除方便的特点。
* 即使是对那些具有指针类型的语言，静态链表也有其用武之地。
* 当线性表的长度不变，仅需改变结点之间的相对关系时，静态链表比动态链表可能更方便。



### 2.8.4 线性表链式存储方式的比较

|     链表名称\操作     |       找表头结点       |         找表尾结点          |           找P结点前驱结点           |
| :-------------: | :---------------: | :--------------------: | :--------------------------: |
|    带头结点单链表L     | L->next    时间O(1) |      一重循环  时间O(n)      |     顺P结点的next域无法找到P结点的前驱     |
| 带头结点循环单链表(头指针)L | L->next    时间O(1) |      一重循环  时间O(n)      | 顺P结点的next域可以找到P结点的前驱  时间O(n) |
|   带尾指针的循环单链表R   | R->next    时间O(1) | R               时间O(1) | 顺P结点的next域可以找到P结点的前驱  时间O(n) |
|   带头结点双向循环链表L   | L->next    时间O(1) |   L->prior   时间O(1)    |      P->prior  时间 O(1)       |



## 2.9经典例题

1. 已知顺序表L中的数据元素类型为int。设计算法将其调整为左右两部分，左边的元素（即排在前面的）均为奇数，右边所有元素（即排在后面的）均为偶数，并要求算法的时间复杂度为O(n)，空间复杂度是O(1)。

   ```c
   void AdjustSqlist(SeqList *L)
   {
     int i = 0;
     int j = L->last;
     while(i < j)
     {
       while(L->elem[i]%2 != 0)
         i++;
       while(L->elem[j]%2 == 0)
         j--;
       if(i < j){
         t = L->elem[i];
         L->elem[i] = L->elem[j];
         L->elem[j] = t;
       }
     }
   }
   ```

   

2. 逆置问题

   ```c
   //顺序表逆置
   void revrese(SeqList *L)
   {
     int i = 0,j = L->last;
     ElemType t;
     while(i < j)
     {
       t = L->elem[i];
       L->elem[i] = L->elem[j];
       L->elem[j] = t;
       i++;j--;
     }
   }
   ```

   ```c
   //单链表逆置
   void ReverseList(LinkList L)
   {
     Node *p,*q;
     p = L->next;		//p为原链表的当前处理结点
     L->next = NULL;	//逆置单链表初始为空表
     while(p != NULL)	//当原链表未处理完
     {
       q = p->next;	//q指针保留原链表当前处理结点的下一个结点
       p->next = L->next;
       L->next = p;
       p = q;			//p指向下一个待插入的结点
     }
   }
   ```

